% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/routestack.R
\docType{data}
\name{RouteStack}
\alias{RouteStack}
\title{Combine multiple routes for sequential routing}
\description{
The \code{RouteStack} class encapsulate multiple \link{Route}s and lets a request be
passed through each sequentially. If a route is returning \code{FALSE} upon
dispatch further dispatching is cancelled.
}
\section{Initialization}{

A new 'RouteStack'-object is initialized using the \code{new()} method on the
generator:

\strong{Usage}
\tabular{l}{
\code{route <- RouteStack$new(...)}
}

\strong{Arguments}
\tabular{lll}{
\code{...} \tab  \tab Routes to add up front. Must be in the form of named
arguments containing \code{Route} objects
}
}

\section{Field}{

The following fields are accessible in a \code{RouteStack} object:

\describe{
\item{\code{header}}{A logical indicating whether the object should be added to
the \code{header} event when used as a \code{fiery} plugin. Defaults to \code{FALSE} (the
object will be added to the \code{request} event)}
\item{\code{name}}{The plugin name (used by \code{fiery}). Will always return \code{'routr'}}
}
}

\section{Methods}{

The following methods are accessible in a \code{RouteStack} object:

\describe{
\item{\code{add_route(route, name, after = NULL)}}{Adds a new route to the stack.
\code{route} must be a \code{Route} object, \code{name} must be a string. If \code{after} is
given the route will be inserted after the given index, if not (or \code{NULL})
it will be inserted in the end of the stack.}
\item{\code{has_route(name)}}{Test if the routestack contains a route with the
given name.}
\item{\code{remove(name}}{Removes the route with the given name from the stack.}
\item{\code{dispatch(request, ...}}{Passes a \link[reqres:Request]{reqres::Request} through the stack
of route in sequence until one of the routes return \code{FALSE} or every route
have been passed through. \code{...} will be passed on to the dispatch of each
\code{Route} on the stack.}
\item{\code{on_attach(app, ...)}}{Method for use by \code{fiery} when attached as a
plugin. Should not be called directly.}
}
}

\examples{
# Create a new stack
routes <- RouteStack$new()

# Populate it wih routes
first <- Route$new()
first$add_handler('all', '*', function(request, response, keys, ...) {
  message('This will always get called first')
  TRUE
})
second <- Route$new()
second$add_handler('get', '/demo/', function(request, response, keys, ...) {
  message('This will get called next if the request asks for /demo/')
  TRUE
})
routes$add_route(first, 'first')
routes$add_route(second, 'second')

# Send a request through
rook <- fiery::fake_request('http://example.com/demo/', method = 'get')
req <- reqres::Request$new(rook)
routes$dispatch(req)

}
\seealso{
\link{Route} for defining single routes
}
\keyword{datasets}
